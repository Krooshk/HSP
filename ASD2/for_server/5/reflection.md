### 3. Алгоритм инвертирования дерева.
    Я использоваль вариант pre-order. Но при реализации, кстати не задумывался о других вариантах (in-order, post-order)
    В остальном всё сделал аналогичным образом.

### 4. Ищем уровень в дереве, сумма значений узлов на котором максимальна.
    Сделал не так, как в эталонном решении. Использовал DFS, в качестве аргументов прокидывал (HashMap, уровень),
    в HashMap записывал значение для уровня. После прохождения по дереву вычислял нужное значение на основе HashMap.

### 5. Восстановление оригинального дерева по префиксу и инфиксу.
    Не завязывался в своем решении на сравнении чисел. Сделал неправильный вывод по поводу построения дерева только по префиксному дереву.
    Переусложнил немного решение, можно было сравнивать значения.

